extends layout
block meta
    meta(name="description", content="OpenArchi Editor")
block scripts
    link(rel='stylesheet', type='text/css', href='/stylesheets/jquery-ui.css')
    link(rel='stylesheet', type='text/css', href='/stylesheets/autocomplete.css')
    script(src='/javascripts/go.js')
    script(type='text/javascript', src='/javascripts/jquery-ui.js')
    script(type='text/javascript', src='/javascripts/OpenArchiWrapper.js')
    script(type='text/javascript', src='/javascripts/editor.js')
    script#code(type="text/javascript")
    script.
        let myDiagram;
        let myPalette;
        let nodeDataArray = '!{nodeDataArray}';
        let linkDataArray = '!{linkDataArray}';
        let MINLENGTH = '!{MINLENGTH}';  // this controls the minimum length of any swimlane
        let MINBREADTH = '!{MINBREADTH}';  // this controls the minimum breadth of any non-collapsed swimlane
        let HORIZONTAL = '!{HORIZONTAL}';  // this constant parameter can only be set here, not dynamically
        let red = '!{red}';
        let green = '!{green}';
        let LinePrefix = '!{LinePrefix}';  // vertical starting point in document for all Messages and Activations
        let LineSuffix = '!{LineSuffix}';  // vertical length beyond the last message time
        let MessageSpacing = '!{MessageSpacing}';  // vertical distance between Messages at different steps
        let ActivityWidth = '!{ActivityWidth}';  // width of each vertical activity bar
        let ActivityStart = '!{ActivityStart}';  // height before start message time
        let ActivityEnd = '!{ActivityEnd}';  // height beyond end message time
        let source = '!{source}';
        let paletteData = !{palette};
        let lightText = 'whitesmoke';

        // Define a function for creating a "port" that is normally transparent.
        // The "name" is used as the GraphObject.portId, the "spot" is used to control how links connect
        // and where the port is positioned on the node, and the boolean "output" and "input" arguments
        // control whether the user can draw links from or to the port.
        function makePort(name, spot, output, input) {
            // the port is basically just a small circle that has a white stroke when it is made visible
            return $(go.Shape, "Circle",
                {
                    fill: "transparent",
                    stroke: null,  // this is changed to "white" in the showPorts function
                    desiredSize: new go.Size(8, 8),
                    alignment: spot, alignmentFocus: spot,  // align the port on the main Shape
                    portId: name,  // declare this object to be a "port"
                    fromSpot: spot, toSpot: spot,  // declare where links may connect at this port
                    fromLinkable: output, toLinkable: input,  // declare whether the user may draw links to/from here
                    cursor: "pointer"  // show a different cursor to indicate potential link point
                });
        }
        // helper definitions for node templates

        function nodeStyle() {
            return [
                // The Node.location comes from the "loc" property of the node data,
                // converted by the Point.parse static method.
                // If the Node.location is changed, it updates the "loc" property of the node data,
                // converting back using the Point.stringify static method.
                new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
                {
                    // the Node.location is at the center of each node
                    locationSpot: go.Spot.Center,
                    //isShadowed: true,
                    //shadowColor: "#888",
                    // handle mouse enter/leave events to show/hide the ports
                    mouseEnter: function (e, obj) {
                        showPorts(obj.part, true);
                    },
                    mouseLeave: function (e, obj) {
                        showPorts(obj.part, false);
                    }
                }
            ];
        }

        // Make all ports on a node visible when the mouse is over the node
        function showPorts(node, show) {
            let diagram = node.diagram;
            if (!diagram || diagram.isReadOnly || !diagram.allowLink) return;
            node.ports.each(function (port) {
                port.stroke = (show ? "white" : null);
            });
        }

        function capitalize(text) {
            return text.substr(1).toUpperCase() + text.substr(2, text.length).toLowerCase();
        }

        function showPaletteByType(paletteData) {
            switch (paletteData.type) {
                case "ARCHITECTURE":
                    // initialize the Palette that is on the left side of the page
                    myPalette =
                        $(go.Palette, "paletteDiv",  // must name or refer to the DIV HTML element
                            {
                                scrollsPageOnFocus: false
                            });

                    let paletteModelArray = [];

                    let templateMap =
                        $(go.Node, "Spot", nodeStyle(),
                            // the main object is a Panel that surrounds a TextBlock with a rectangular Shape
                            $(go.Panel, "Auto",
                                $(go.Shape, "Rectangle",
                                    {fill: "#00A9C9", stroke: null},
                                    new go.Binding("figure", "figure")),
                                $(go.TextBlock,
                                    {
                                        font: "bold 11pt Helvetica, Arial, sans-serif",
                                        stroke: lightText,
                                        margin: 8,
                                        maxSize: new go.Size(160, NaN),
                                        wrap: go.TextBlock.WrapFit,
                                        editable: true
                                    },
                                    new go.Binding("text").makeTwoWay())
                            ),
                            // four named ports, one on each side:
                            makePort("T", go.Spot.Top, true, true),
                            makePort("L", go.Spot.Left, true, true),
                            makePort("R", go.Spot.Right, true, true),
                            makePort("B", go.Spot.Bottom, true, true)
                        );

                    paletteData.basicElements.forEach(function (data) {
                        var shapeType = capitalize(data.shapeType);
                        const input = data.input;
                        const output = data.output;
                        let paletteModel = {}
                        paletteModel.category = data.name;
                        paletteModel.text = data.name;
                        paletteModel.figure = shapeType;
                        paletteModelArray.push(paletteModel);
                        templateMap.add(data.name,
                            $(go.Node, "Spot", nodeStyle(),
                                $(go.Panel, "Auto",
                                    $(go.Shape, shapeType,
                                        {
                                            minSize: new go.Size(data.size.width, data.size.height),
                                            fill: data.fill,
                                            stroke: data.stroke
                                        }),
                                    $(go.TextBlock, data.name,
                                        {font: "bold 11pt Helvetica, Arial, sans-serif", stroke: lightText},
                                        new go.Binding("text"))
                                ),
                                // three named ports, one on each side except the top, all output only:
                                // four named ports, one on each side:
                                makePort("T", go.Spot.Top, input, output),
                                makePort("L", go.Spot.Left, input, output),
                                makePort("R", go.Spot.Right, input, output),
                                makePort("B", go.Spot.Bottom, input, output)
                            ));
                    });

                    paletteData.softwareSystems.forEach(function (data) {
                        var shapeType = capitalize(data.shapeType);
                        const input = data.input;
                        const output = data.output;
                        let paletteModel = {}
                        paletteModel.category = data.name;
                        paletteModel.text = data.name;
                        paletteModel.figure = shapeType;
                        paletteModelArray.push(paletteModel);
                        templateMap.add(data.name,
                            $(go.Node, "Spot", nodeStyle(),
                                $(go.Panel, "Auto",
                                    $(go.Shape, shapeType,
                                        {
                                            minSize: new go.Size(data.size.width, data.size.height),
                                            fill: data.fill,
                                            stroke: data.stroke
                                        }),
                                    $(go.TextBlock, data.name,
                                        {font: "bold 11pt Helvetica, Arial, sans-serif", stroke: lightText},
                                        new go.Binding("text"))
                                ),
                                // three named ports, one on each side except the top, all output only:
                                // four named ports, one on each side:
                                makePort("T", go.Spot.Top, input, output),
                                makePort("L", go.Spot.Left, input, output),
                                makePort("R", go.Spot.Right, input, output),
                                makePort("B", go.Spot.Bottom, input, output)
                            ));
                    });

                    paletteData.containers.forEach(function (data) {
                        var shapeType = capitalize(data.shapeType);
                        const input = data.input;
                        const output = data.output;
                        let paletteModel = {}
                        paletteModel.category = data.name;
                        paletteModel.text = data.name;
                        paletteModel.figure = shapeType;
                        paletteModelArray.push(paletteModel);
                        templateMap.add(data.name,
                            $(go.Node, "Spot", nodeStyle(),
                                $(go.Panel, "Auto",
                                    $(go.Shape, shapeType,
                                        {
                                            minSize: new go.Size(data.size.width, data.size.height),
                                            fill: data.fill,
                                            stroke: data.stroke
                                        }),
                                    $(go.TextBlock, data.name,
                                        {font: "bold 11pt Helvetica, Arial, sans-serif", stroke: lightText},
                                        new go.Binding("text"))
                                ),
                                // three named ports, one on each side except the top, all output only:
                                // four named ports, one on each side:
                                makePort("T", go.Spot.Top, input, output),
                                makePort("L", go.Spot.Left, input, output),
                                makePort("R", go.Spot.Right, input, output),
                                makePort("B", go.Spot.Bottom, input, output)
                            ));
                    });

                    paletteData.components.forEach(function (data) {
                        var shapeType = capitalize(data.shapeType);
                        const input = data.input;
                        const output = data.output;
                        let paletteModel = {}
                        paletteModel.category = data.name;
                        paletteModel.text = data.name;
                        paletteModel.figure = shapeType;
                        paletteModelArray.push(paletteModel);
                        templateMap.add(data.name,
                            $(go.Node, "Spot", nodeStyle(),
                                $(go.Panel, "Auto",
                                    $(go.Shape, shapeType,
                                        {
                                            minSize: new go.Size(data.size.width, data.size.height),
                                            fill: data.fill,
                                            stroke: data.stroke
                                        }),
                                    $(go.TextBlock, data.name,
                                        {font: "bold 11pt Helvetica, Arial, sans-serif", stroke: lightText},
                                        new go.Binding("text"))
                                ),
                                // three named ports, one on each side except the top, all output only:
                                // four named ports, one on each side:
                                makePort("T", go.Spot.Top, input, output),
                                makePort("L", go.Spot.Left, input, output),
                                makePort("R", go.Spot.Right, input, output),
                                makePort("B", go.Spot.Bottom, input, output)
                            ));
                    });

                    myPalette.nodeTemplateMap = templateMap;
                    myPalette.model = new go.GraphLinksModel(paletteModelArray);
                    break;
                case "BPM":
                    break;
                case "FLOWCHART":
                    break;
                case "SEQUENCE":
                    break;
                case "GANTT":
                    break;
                case "ENTITY_RELATIONSHIP":
                    break;
                case "UML_CLASS":
                    break;
                default:
                    console.log("Still not implemented");
            }
        }

        $(function () {
            var showMenuFlag = !{showMenu};
            if (showMenuFlag !== undefined && showMenuFlag !== null && showMenuFlag) {
                $.getScript("/javascripts/menu.js").done(function (script, textStatus) {
                    showMenu();
                });
            }
            switch (source) {
                case "basic":
                    $.getScript("/javascripts/diagrams/basic.js").done(function (script, textStatus) {
                        initBasic(nodeDataArray, linkDataArray);
                    });
                    break;
                default:
                    console.log("Still not implemented");
            }

            if (paletteData !== '') {
                showPaletteByType(paletteData);
            }

            var dataArray;
            $("#diagramId").autocomplete({
                minLength: 3,
                source: function (request, response) {
                    $.get("/open-archi/api/models", {$filter: "name=='*" + request.term + "*'"})
                        .done(function (data) {
                            var models = [{id: "-1", value: "Select one..."}];
                            dataArray = data;
                            if (Array.isArray(data)) {
                                data.forEach(function (model) {
                                    models.push({id: model.id, value: model.name});
                                });
                                response(models);
                            } else {
                                response({});
                            }
                        });
                },
                select: function (event, element) {
                    var id = element.item.id;
                    var model = dataArray.find(function (model) {
                        return model.id === id;
                    });
                    $("#modelToSaveOrLoad").html(JSON.stringify(model, null, 2));
                    openModel(model);
                },
                // optional (if other layers overlap autocomplete list)
                open: function (event, ui) {
                    $(".ui-autocomplete").css("z-index", 1000);
                }
            }).on("click", function () {
                $(this).select();
            });
        });

block content
    div#mainContainer(style="padding-bottom: 15px;")
        //select#diagram-types-combo
        //    option(value="NONE") Seleccione uno
        //    each diagramType in diagramTypes
        //        option(value=diagramType)= diagramType
        //select#diagram-views(onchange="switchDiagrams")
        //    option(value="DEFAULT") Default
        //    option(value="TREE") Tree
        //    option(value="ER") ER
        input#diagramId(name='diagramId', placeholder='Nombre del diagrama...')
        div(style="padding-top: 15px")
            button#SaveButton(onclick="save()") Guardar
            | &nbsp;
            button#LoadButton(onclick="load()") Cargar
            | &nbsp;
            button#OpenSVGButton(onclick="openSVG()") Exportar como SVG
        div#diagramsCanvas(style="justify-content: space-between")
            div#explanation
                h2#mainTitle(style="margin-top: 0; padding-top: 0; margin-bottom: 30px;")= mainTitle
                h2#caption(style="margin-top: 0; padding-top: 0; margin-bottom: 30px; color: red; text-align: right;")= caption
                p= fullDescription
                if steps
                    ul
                        each step in steps
                            li= step
                if mainTitle
                    strong Como todos lo demás elementos, se pueden combinar éstas caractrísticas con las presentes en otros ejemplos para crear capacidades más complejas
            div(style="width: 100%; display: flex;")
                div#paletteDiv(style="width: 15%; height:400px; border: solid gray 1px; overflow: scroll; margin-right: 2px; ")
                div#diagramDiv(style="width: 85%; height:400px; border: solid gray 1px; overflow: scroll; margin-right: 2px; ")
            if nodeDataArray
                div
                    p Aquí se pueden visualizar los datos que permiten almacenar y/o recuperar el diagrama expuesto arriba (Utilizando las APIs definidas en: /open-archi/api), en formato JSON y en tiempo real
                    div(style="display: inline; min-width: 300px;")
                    textarea#modelToSaveOrLoad(style="width:100%;height:300px")